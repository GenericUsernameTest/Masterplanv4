/**
 * UI Management Module
 * Centralized functions for managing UI elements, buttons, and display updates
 */

/**
 * --- Site ID helpers (ensure ?site=site-XXXXX is always in the URL) ---
 */
function getSiteIdFromUrl() {
  try {
    const url = new URL(window.location.href);
    const site = url.searchParams.get('site');
    return site && site.trim() ? site.trim() : null;
  } catch (e) {
    return null;
  }
}

function setSiteIdInUrl(siteId, method = 'replace') {
  try {
    if (!siteId) return;
    const url = new URL(window.location.href);
    if (url.searchParams.get('site') === siteId) return; // already set
    url.searchParams.set('site', siteId);
    const newUrl = url.pathname + url.search + url.hash;
    if (method === 'push') {
      window.history.pushState({}, '', newUrl);
    } else {
      window.history.replaceState({}, '', newUrl);
    }
  } catch (e) {
    // no-op
  }
}

function ensureSiteIdInUrl() {
  // 1) From URL
  const fromUrl = getSiteIdFromUrl();
  if (fromUrl) {
    localStorage.setItem('activeSiteId', fromUrl);
    return fromUrl;
  }
  // 2) From previous session
  const active = localStorage.getItem('activeSiteId');
  if (active) {
    setSiteIdInUrl(active, 'replace');
    return active;
  }
  // 3) As a last resort, create a minimal site (saveMinimalSite will set activeSiteId)
  try {
    if (typeof saveMinimalSite === 'function') {
      saveMinimalSite();
      const gen = localStorage.getItem('activeSiteId');
      if (gen) setSiteIdInUrl(gen, 'replace');
      return gen || null;
    }
  } catch {}
  return null;
}

// Expose a stable getter expected by other modules
window.getCurrentSiteId = function() {
  return ensureSiteIdInUrl();
};

// Run immediately so main.js can see a proper ?site= in the URL
ensureSiteIdInUrl();

/**
 * Generic button show/hide functionality
 * @param {string} buttonId - ID of the button element
 * @param {boolean} show - Whether to show or hide the button
 * @param {function} clickHandler - Optional click handler function
 * @param {string} text - Optional text to set
 */
const toggleButton = (buttonId, show, clickHandler = null, text = null) => {
  const btn = document.getElementById(buttonId);
  if (btn) {
    btn.style.display = show ? 'block' : 'none';
    if (clickHandler) {
      btn.onclick = clickHandler;
    }
    if (text) {
      btn.textContent = text;
    }
  }
};

/**
 * Update multiple elements with the same text content
 * @param {string|array} selectors - CSS selector(s) for elements to update
 * @param {string} text - Text content to set
 */
const updateElements = (selectors, text) => {
  const selectorList = Array.isArray(selectors) ? selectors : [selectors];
  selectorList.forEach(selector => {
    const elements = document.querySelectorAll(selector);
    elements.forEach(el => {
      el.textContent = text;
    });
  });
};

/**
 * Update home count display across multiple UI elements
 * @param {number} count - Number of homes to display
 */
const updateHomeCount = (count) => {
  
  // Update count display elements (just the number since labels are in HTML)
  updateElements(['.home-count', '#home-count'], count);
  
  // Update generate homes button text if it exists
  const generateBtn = document.getElementById('generate-homes');
  if (generateBtn && count > 0) {
    generateBtn.textContent = `Regenerate Homes (${count})`;
  }
};

/**
 * Generic modal/overlay management
 * @param {string} overlayId - ID of overlay element
 * @param {boolean} show - Whether to show or hide
 * @param {function} closeCallback - Optional callback when closed
 */
const toggleOverlay = (overlayId, show, closeCallback = null) => {
  const overlay = document.getElementById(overlayId);
  if (overlay) {
    overlay.style.display = show ? 'flex' : 'none';
    
    if (show) {
      // Add click-outside-to-close functionality
      const handleClick = (e) => {
        if (e.target === overlay) {
          toggleOverlay(overlayId, false, closeCallback);
          overlay.removeEventListener('click', handleClick);
        }
      };
      overlay.addEventListener('click', handleClick);
      
      // Add escape key handler
      const handleEscape = (e) => {
        if (e.key === 'Escape') {
          toggleOverlay(overlayId, false, closeCallback);
          document.removeEventListener('keydown', handleEscape);
        }
      };
      document.addEventListener('keydown', handleEscape);
    } else if (closeCallback) {
      closeCallback();
    }
  }
};

/**
 * Update area display with proper formatting
 * @param {number} areaHa - Area in hectares
 */
const updateAreaDisplay = (areaHa) => {
  const areaText = areaHa >= 0.01 
    ? `${areaHa.toFixed(2)} ha` 
    : `${Math.round(areaHa * 10000)} m²`;
  
  updateElements(['#site-area', '.site-area'], areaText);
};

/**
 * Create and show loading indicator
 * @param {string} message - Loading message
 * @param {string} containerId - Optional container ID
 * @returns {function} Function to hide the loading indicator
 */
const showLoading = (message = 'Loading...', containerId = null) => {
  const loadingId = 'loading-indicator';
  let existing = document.getElementById(loadingId);
  
  if (existing) {
    existing.remove();
  }
  
  const loading = document.createElement('div');
  loading.id = loadingId;
  loading.innerHTML = `
    <div style="
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10001;
    ">
      <div style="
        background: white;
        padding: 20px;
        border-radius: 8px;
        text-align: center;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      ">
        <div style="
          width: 40px;
          height: 40px;
          border: 4px solid #f3f3f3;
          border-top: 4px solid #3498db;
          border-radius: 50%;
          animation: spin 1s linear infinite;
          margin: 0 auto 10px;
        "></div>
        <div>${message}</div>
      </div>
    </div>
  `;
  
  // Add CSS animation
  if (!document.getElementById('loading-styles')) {
    const style = document.createElement('style');
    style.id = 'loading-styles';
    style.textContent = `
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
    `;
    document.head.appendChild(style);
  }
  
  const container = containerId ? document.getElementById(containerId) : document.body;
  container.appendChild(loading);
  
  return () => {
    const el = document.getElementById(loadingId);
    if (el) el.remove();
  };
};

/**
 * Create a navbar button with consistent styling
 * @param {Object} config - Button configuration
 * @param {string} config.id - Button ID
 * @param {string} config.text - Button text
 * @param {string} config.icon - Optional icon (emoji)
 * @param {function} config.onClick - Click handler
 * @param {string} config.className - CSS class (default: 'btn-small')
 * @param {HTMLElement} config.parent - Parent element to append to
 * @returns {HTMLElement} Created button element
 */
const createNavButton = (config) => {
  const {
    id,
    text,
    icon = '',
    onClick,
    className = 'btn-small',
    parent
  } = config;

  const btn = document.createElement('button');
  btn.id = id;
  btn.textContent = icon ? `${icon} ${text}` : text;
  btn.className = className;
  
  // Add consistent styling
  btn.style.marginLeft = '12px';
  
  if (onClick) {
    btn.addEventListener('click', onClick);
  }
  
  if (parent) {
    parent.appendChild(btn);
  }
  
  return btn;
};

/**
 * Create multiple navbar buttons with consistent styling
 * @param {Array} buttonsConfig - Array of button configurations
 * @param {HTMLElement} parent - Parent element to append buttons to
 * @returns {Array} Array of created button elements
 */
const createButtonGroup = (buttonsConfig, parent) => {
  return buttonsConfig.map(config => createNavButton({
    ...config,
    parent
  }));
};

/**
 * Initialize editable site name in the navbar
 * Loads saved name from localStorage and updates it on blur or Enter key press
 */
const initSiteNameEditable = () => {
  const span = document.querySelector('#site-name-nav span');
  if (!span) return;
  
  const storageKey = 'siteName';
  const savedName = localStorage.getItem(storageKey);
  if (savedName) {
    span.textContent = savedName;
  }
  
  span.setAttribute('contenteditable', 'true');
  span.style.outline = 'none';
  
  const saveName = () => {
    const name = span.textContent.trim();
    if (name) {
      localStorage.setItem(storageKey, name);
    }
  };
  
  span.addEventListener('blur', () => {
    saveName();
  });
  
  span.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      span.blur();
    }
  });
};

/**
 * Remove empty CSS files and manage button styling
 * Note: This module references but doesn't define CSS classes
 * CSS classes should be defined in styles.css:
 * - .btn-small: Small button styling
 * - .btn-primary: Primary action button
 * - .btn-secondary: Secondary action button
 */

/**
 * Initialize navbar dropdown menu functionality
 * Sets up the three-dots menu toggle behavior
 */
function initializeNavDropdown() {
  // Prevent multiple initializations
  if (initializeNavDropdown._initialized) {
    console.log('📋 Nav dropdown already initialized, skipping...');
    return;
  }

  console.log('🚀 Initializing nav dropdown...');

  const navEllipsis = document.getElementById('nav-ellipsis');
  const navMenu = document.getElementById('nav-menu');
  const houseTypesBtn = document.getElementById('house-types-btn');
  const resetBoundaryBtn = document.getElementById('reset-boundary-btn');
  const aiAnalyzeSiteBtn = document.getElementById('ai-analyze-site-btn');

  console.log('📋 Elements found:', {
    navEllipsis: !!navEllipsis,
    navMenu: !!navMenu,
    houseTypesBtn: !!houseTypesBtn,
    resetBoundaryBtn: !!resetBoundaryBtn,
    aiAnalyzeSiteBtn: !!aiAnalyzeSiteBtn
  });

  if (!navEllipsis || !navMenu) {
    console.warn('Navigation dropdown elements not found');
    return;
  }

  // Toggle dropdown menu on ellipsis click
  navEllipsis.addEventListener('click', (e) => {
    e.stopPropagation();
    const expanded = navEllipsis.getAttribute('aria-expanded') === 'true';
    navEllipsis.setAttribute('aria-expanded', String(!expanded));
    navMenu.setAttribute('aria-hidden', String(expanded));
    // Use CSS class to show/hide dropdown
    if (expanded) {
      navMenu.classList.remove('open');
    } else {
      navMenu.classList.add('open');
    }
  });

  // Close dropdown when clicking outside
  document.addEventListener('click', (e) => {
    if (!navEllipsis.contains(e.target) && !navMenu.contains(e.target)) {
      navMenu.setAttribute('aria-hidden', 'true');
      navEllipsis.setAttribute('aria-expanded', 'false');
      navMenu.classList.remove('open');
    }
  });

  // Auto-close dropdown when any menu item is clicked
  navMenu.addEventListener('click', (e) => {
    // Check if clicked element is a menu item (button or has menu-item class)
    if (e.target.classList.contains('menu-item') || e.target.closest('.menu-item')) {
      // Small delay to allow the button action to complete first
      setTimeout(() => {
        navMenu.setAttribute('aria-hidden', 'true');
        navEllipsis.setAttribute('aria-expanded', 'false');
        navMenu.classList.remove('open');
      }, 10);
    }
  });

  // Handle menu button clicks
  if (houseTypesBtn) {
    houseTypesBtn.addEventListener('click', () => {
      // Close menu after action
      navMenu.setAttribute('aria-hidden', 'true');
      navEllipsis.setAttribute('aria-expanded', 'false');
      navMenu.classList.remove('open');
      // TODO: Implement house types functionality
    });
  }

  if (resetBoundaryBtn) {
    resetBoundaryBtn.addEventListener('click', () => {
      // Close menu after action
      navMenu.setAttribute('aria-hidden', 'true');
      navEllipsis.setAttribute('aria-expanded', 'false');
      navMenu.classList.remove('open');

      // Call the clearAll function to reset boundary and polygons
      // Try multiple ways to access the function
      if (typeof window.clearAll === 'function') {
        window.clearAll();
        console.log('✅ Reset boundary using window.clearAll');
      } else {
        // Fallback: manually clear the boundary
        console.log('⚠️ window.clearAll not available, attempting manual reset');

        // Clear draw features
        if (window.draw) {
          window.draw.deleteAll();
          window.draw.changeMode('simple_select');
        }

        // Clear site boundary
        window.siteBoundary = null;

        // Clear localStorage
        localStorage.removeItem('siteBoundary');

        // Reset cursor
        if (window.map) {
          window.map.getCanvas().style.cursor = '';
        }

        // Trigger UI updates if functions are available
        if (typeof window.refreshPerimeter === 'function') {
          window.refreshPerimeter();
        }
        if (typeof window.updateAreaDisplay === 'function') {
          window.updateAreaDisplay(0);
        }
        if (typeof window.toggleGenerateButton === 'function') {
          window.toggleGenerateButton(false);
        }

        console.log('✅ Manual boundary reset completed');
      }

      // After clearing, automatically activate draw boundary mode
      setTimeout(() => {
        if (window.draw && window.map) {
          try {
            window.draw.changeMode('draw_polygon');
            console.log('✅ Activated draw boundary mode');

            // Show draw hint if the function is available
            if (typeof window.showDrawHint === 'function') {
              window.showDrawHint();
            }
          } catch (error) {
            console.error('❌ Error activating draw mode:', error);
          }
        } else {
          console.error('❌ Draw tool or map not available for activation');
        }
      }, 100); // Small delay to ensure cleanup is complete
    });
  }


  // AI Analyze Site button handler
  if (aiAnalyzeSiteBtn) {
    console.log("✅ Found AI Analyze Site button, attaching handler...");
    aiAnalyzeSiteBtn.addEventListener('click', async function handleAiClick(e) {
      console.log("⚙️ Starting AI analysis process...");
      // 🚫 Prevent all possible default browser behaviors immediately
      if (e) {
        e.preventDefault();
        e.stopImmediatePropagation();
        e.stopPropagation();
      }

      // Explicitly prevent form submission or navigation
      if (this.tagName === "A") this.removeAttribute("href");
      if (this.type === "submit") this.setAttribute("type", "button");
      window.onbeforeunload = null;

      console.log("🖱️ AI Analyze Site button clicked — default actions fully disabled");

      // Close dropdown
      navMenu.setAttribute('aria-hidden', 'true');
      navEllipsis.setAttribute('aria-expanded', 'false');
      navMenu.classList.remove('open');

      const originalText = aiAnalyzeSiteBtn.textContent;
      aiAnalyzeSiteBtn.textContent = '🔄 Analyzing...';
      aiAnalyzeSiteBtn.disabled = true;

      try {
        if (!window.siteBoundary || typeof window.exportSiteAnalysisToDataFolder !== 'function') {
          throw new Error("Missing site boundary or export function");
        }

        const siteId = window.getCurrentSiteId?.() || `site-${Date.now()}`;
        const boundary = window.siteBoundary.geometry.coordinates[0];

        console.log("💾 Saving latest site analysis before AI run...");
        await window.exportSiteAnalysisToDataFolder(boundary, siteId);
        console.log(`✅ Site analysis saved successfully for: ${siteId}`);

        const apiBase = "http://127.0.0.1:4000";
        console.log(`📡 Sending AI task request to: ${apiBase}/run-ai-task1/${siteId}`);

        // --- BEGIN: Check for redirect on fetch to prevent navigation ---
        let response;
        try {
          response = await fetch(`${apiBase}/run-ai-task1/${siteId}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
          });
        } catch (fetchErr) {
          throw fetchErr;
        }
        if (response.redirected) {
          console.error("🚫 Redirect detected to:", response.url);
          throw new Error("Unexpected redirect — likely page refresh issue");
        }
        if (!response.ok) throw new Error(`AI endpoint error: ${response.status}`);
        // --- END: Check for redirect on fetch to prevent navigation ---

        console.log("✅ AI task executed, awaiting response file...");
        console.log("⌛ Waiting for AI response file to be written...");

        // Retry fetching the AI response file up to 10 times (5 seconds)
        async function waitForAIResponse(url, retries = 10, delay = 500) {
          for (let i = 0; i < retries; i++) {
            const response = await fetch(url);
            if (response.ok) return response.json();
            await new Promise(r => setTimeout(r, delay));
          }
          throw new Error("AI response file not found after waiting");
        }

        const aiResponseUrl = `${apiBase}/data/${siteId}-response.json`;
        console.log("📄 Fetching AI response from:", aiResponseUrl);
        const aiResponse = await waitForAIResponse(aiResponseUrl);
        console.log("🧠 AI response successfully fetched, ready for map update.");
        console.log("🤖 AI Response received:", aiResponse);

        // === Draw south boundary edge in red to indicate AI analysis completion ===
        (function drawSouthBoundaryEdge() {
          if (!window.siteBoundary) {
            console.warn("No siteBoundary found: cannot draw south edge highlight.");
            return;
          }
          if (!window.map) {
            console.warn("No map found on window: cannot draw south edge highlight.");
            return;
          }
          let coords = window.siteBoundary.geometry?.coordinates?.[0];
          if (!Array.isArray(coords) || coords.length < 2) {
            console.warn("siteBoundary coordinates unavailable or too short.");
            return;
          }
          // Remove duplicate closing coordinate if present
          if (
            coords.length > 2 &&
            coords[0][0] === coords[coords.length - 1][0] &&
            coords[0][1] === coords[coords.length - 1][1]
          ) {
            coords = coords.slice(0, -1);
          }
          // Find the edge (pair of consecutive coords) with lowest average latitude (Y)
          let minLat = Infinity, minIdx = -1;
          for (let i = 0; i < coords.length; i++) {
            const a = coords[i];
            const b = coords[(i + 1) % coords.length];
            const avgLat = (a[1] + b[1]) / 2;
            if (avgLat < minLat) {
              minLat = avgLat;
              minIdx = i;
            }
          }
          if (minIdx === -1) {
            console.warn("Could not determine southernmost edge.");
            return;
          }
          const southEdge = [
            coords[minIdx],
            coords[(minIdx + 1) % coords.length]
          ];
          const geojson = {
            type: "Feature",
            geometry: { type: "LineString", coordinates: southEdge },
            properties: { name: "south-boundary-edge" }
          };
          const sourceId = "ai-south-boundary-edge";
          const layerId = "ai-south-boundary-edge-layer";
          const map = window.map;
          if (!map.getSource(sourceId)) {
            map.addSource(sourceId, { type: "geojson", data: geojson });
            map.addLayer({
              id: layerId,
              type: "line",
              source: sourceId,
              paint: {
                "line-color": "#ff2222",
                "line-width": 5
              }
            });
          } else {
            map.getSource(sourceId).setData(geojson);
          }
        })();

        if (typeof window.highlightRecommendedEdges === 'function') {
          window.highlightRecommendedEdges(aiResponse, aiResponse);
        }

        if (typeof window.showNotification === 'function') {
          window.showNotification('✅ AI analysis complete!', 'success');
        } else {
          alert('✅ AI analysis complete!');
        }
      } catch (err) {
        console.error('❌ AI analysis failed:', err);
        if (typeof window.showNotification === 'function') {
          window.showNotification('AI analysis failed: ' + err.message, 'error');
        } else {
          alert('AI analysis failed: ' + err.message);
        }
      } finally {
        aiAnalyzeSiteBtn.textContent = originalText;
        aiAnalyzeSiteBtn.disabled = false;
      }

      // Prevent any page reload or navigation
      return false;
    });
  } else {
    console.log("❌ AI Analyze Site button not found in DOM");
  }

  // Keyboard navigation for menu
  navMenu.addEventListener('keydown', (e) => {
    const menuItems = navMenu.querySelectorAll('.menu-item');
    const currentIndex = Array.from(menuItems).indexOf(document.activeElement);

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        const nextIndex = (currentIndex + 1) % menuItems.length;
        menuItems[nextIndex].focus();
        break;
      case 'ArrowUp':
        e.preventDefault();
        const prevIndex = (currentIndex - 1 + menuItems.length) % menuItems.length;
        menuItems[prevIndex].focus();
        break;
      case 'Escape':
        navMenu.setAttribute('aria-hidden', 'true');
        navEllipsis.setAttribute('aria-expanded', 'false');
        navMenu.classList.remove('open');
        navEllipsis.focus();
        break;
      case 'Enter':
      case ' ':
        e.preventDefault();
        document.activeElement.click();
        break;
    }
  });

  // Mark as initialized to prevent duplicate setup
  initializeNavDropdown._initialized = true;
  console.log('✅ Nav dropdown initialization complete');
}

/**
 * Show a notification (simple implementation)
 * @param {string} message - HTML message to display
 * @param {'success'|'error'|'info'} type
 */
function showNotification(message, type = 'info') {
  // Remove existing notification if present
  let existing = document.getElementById('global-notification');
  if (existing) existing.remove();
  const notif = document.createElement('div');
  notif.id = 'global-notification';
  notif.innerHTML = message;
  notif.style.position = 'fixed';
  notif.style.top = '24px';
  notif.style.left = '50%';
  notif.style.transform = 'translateX(-50%)';
  notif.style.zIndex = 10010;
  notif.style.background = type === 'success' ? '#e6ffe6' : type === 'error' ? '#ffe6e6' : '#eef';
  notif.style.color = type === 'success' ? '#1a4' : type === 'error' ? '#a11' : '#222';
  notif.style.padding = '16px 28px';
  notif.style.borderRadius = '8px';
  notif.style.boxShadow = '0 2px 16px rgba(0,0,0,0.12)';
  notif.style.fontSize = '1.1em';
  notif.style.maxWidth = '80vw';
  notif.style.textAlign = 'left';
  notif.style.pointerEvents = 'auto';
  notif.style.cursor = 'pointer';
  notif.style.transition = 'opacity 0.2s';
  notif.addEventListener('click', () => notif.remove());
  document.body.appendChild(notif);
  setTimeout(() => {
    notif.style.opacity = '0';
    setTimeout(() => notif.remove(), 1400);
  }, 4000);
}

/**
 * Auto-start drawing mode when no site boundary exists
 */
function initializeDrawMode() {
  
  // Make UI functions globally available
  window.showDrawHint = showDrawHint;
  window.removeDrawHint = removeDrawHint;
  
  // Add global function to start drawing
  window.startDrawing = () => {
    if (window.draw && !window.siteBoundary && !window.blockPlacementMode) {
      try {
        window.draw.changeMode('draw_polygon');
        return true;
      } catch (err) {
        console.warn('⚠️ Failed to start draw mode manually:', err);
        return false;
      }
    }
    return false;
  };
  
  // Wait for draw controls to be ready and auto-start if no boundary
  const tryInitDraw = () => {
    if (!window.siteBoundary && window.draw && !window.blockPlacementMode) {
      try {
        // Start drawing mode automatically when no boundary exists
        window.draw.changeMode('draw_polygon');
      } catch (err) {
        console.warn('⚠️ Failed to auto-start draw mode:', err);
      }
    } else {
    }
  };
  
  // Try immediately, then with delay if needed
  if (window.draw) {
    tryInitDraw();
  } else {
    // Wait for draw to be initialized
    setTimeout(tryInitDraw, 200);
  }
}

/**
 * Initialize site name persistence functionality
 * Saves the site name to localStorage when the user edits it
 */
function initializeSiteNamePersistence() {
  const siteNameEl = document.querySelector('#site-name-nav span');
  if (!siteNameEl) {
    console.warn('⚠️ Site name element not found');
    return;
  }
  
  // Load saved site name on startup
  const savedName = localStorage.getItem('siteName');
  if (savedName && savedName.trim()) {
    siteNameEl.textContent = savedName.trim();
  }
  
  // Save site name when user edits it
  siteNameEl.addEventListener('input', () => {
    const currentName = siteNameEl.textContent.trim();
    if (currentName) {
      localStorage.setItem('siteName', currentName);
      
      // Auto-save the site with new name if we have an active site
      const activeId = localStorage.getItem('activeSiteId');
      if (activeId && typeof window.autoSaveCurrentSite === 'function') {
        setTimeout(() => window.autoSaveCurrentSite(), 500); // Small delay to avoid too frequent saves
      }
    }
  });
  
  // Also save on blur to catch any changes and ensure sync
  siteNameEl.addEventListener('blur', () => {
    // Use the sync function to ensure everything is consistent
    if (typeof window.syncSiteName === 'function') {
      window.syncSiteName();
    }
    
    // Always try to save the site, even without a boundary
    const activeId = localStorage.getItem('activeSiteId');
    if (activeId && typeof window.autoSaveCurrentSite === 'function') {
      window.autoSaveCurrentSite();
    } else {
      // If no active site ID and no boundary, create a minimal site entry
      saveMinimalSite();
    }
  });
  
  // Save on Enter key press
  siteNameEl.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      siteNameEl.blur(); // This will trigger the blur event and save
    }
  });
  
}

/**
 * Save a minimal site entry when there's no boundary yet
 * This ensures new sites appear in the profile page even before drawing
 */
function saveMinimalSite() {
  const siteName = localStorage.getItem('siteName') || 'Untitled Site';
  
  // Generate a new site ID
    // Generate a new site ID (simple format)\n  const siteId = `site-${Date.now()}`;",
  
  // Create minimal site object
  const site = {
    id: siteId,
    name: siteName,
    geojson: {
      type: 'FeatureCollection',
      features: [] // No boundary yet
    },
    meta: { phase: 1 },
    timestamp: new Date().toISOString(),
    lastModified: new Date().toISOString()
  };
  
  // Add to savedSites array
  let savedSites = JSON.parse(localStorage.getItem('savedSites') || '[]');
  
  // Check if a site with this name already exists
  const existingIndex = savedSites.findIndex(s => s.name === siteName);
  
  if (existingIndex >= 0) {
    // Update existing site
    savedSites[existingIndex] = { ...savedSites[existingIndex], ...site };
  } else {
    // Add new site
    savedSites.push(site);
  }
  
  localStorage.setItem('savedSites', JSON.stringify(savedSites));
  localStorage.setItem('activeSiteId', siteId);
  setSiteIdInUrl(siteId, 'replace');
  
  console.log('💾 Saved minimal site:', siteName, 'with ID:', siteId);
}

/**
 * Show draw hint when drawing polygon
 */
function showDrawHint() {
  
  // Check if we should show the hint
  try {
    const mode = window.draw?.getMode?.() || '';
    if (mode !== 'draw_polygon' || window.siteBoundary) { 
      removeDrawHint(); 
      return; 
    }
  } catch {}
  
  // Remove any existing hint first
  removeDrawHint();
  
  const el = document.createElement('div');
  el.id = 'draw-hint';
  el.textContent = 'Click to draw boundary';
  
  // Add inline styles to ensure visibility
  el.style.position = 'fixed';
  el.style.left = '50%';
  el.style.transform = 'translateX(-50%)';
  el.style.zIndex = '2100';
  el.style.pointerEvents = 'none';
  
  document.body.appendChild(el);
  
  // Position 20px below the navbar
  try {
    const nav = document.querySelector('.navbar');
    if (nav) {
      const rect = nav.getBoundingClientRect();
      const top = (rect.bottom || 60) + 20 + window.scrollY; // 20px below navbar
      el.style.top = `${top}px`;
    } else {
      // fallback: position below expected navbar height
      el.style.top = '90px';
    }
  } catch (error) {
    el.style.top = '90px';
  }
  
  // Force visibility with a slight delay
  setTimeout(() => {
    const hintEl = document.getElementById('draw-hint');
    if (hintEl) {
      hintEl.style.display = 'block';
      hintEl.style.visibility = 'visible';
      hintEl.style.opacity = '1';
    }
  }, 50);
  
  // Update on resize and scroll
  if (!window._drawHintResizeHandler) {
    window._drawHintResizeHandler = () => {
      const nav = document.querySelector('.navbar');
      const drawHint = document.getElementById('draw-hint');
      if (!drawHint) return;
      if (nav) {
        const rect = nav.getBoundingClientRect();
        const top = (rect.bottom || 60) + 20 + window.scrollY;
        drawHint.style.top = `${top}px`;
      }
    };
    window.addEventListener('resize', window._drawHintResizeHandler);
    window.addEventListener('scroll', window._drawHintResizeHandler, { passive: true });
  }
}

/**
 * Remove draw hint
 */
function removeDrawHint() {
  const el = document.getElementById('draw-hint');
  if (el) {
    el.remove();
  }
  
  // Clean up event listeners
  if (window._drawHintResizeHandler) {
    window.removeEventListener('resize', window._drawHintResizeHandler);
    window.removeEventListener('scroll', window._drawHintResizeHandler);
    window._drawHintResizeHandler = null;
  }
}

/**
 * Toggle generate homes button visibility
 * @param {boolean} show - Whether to show or hide the button
 */
function toggleGenerateButton(show) {
  const generateBtn = document.getElementById('generate-homes');
  if (generateBtn) {
    if (show) {
      generateBtn.classList.remove('hidden');
    } else {
      generateBtn.classList.add('hidden');
    }
  }
  
  // Also show/hide block placement panel
  const blockPanel = document.getElementById('block-placement-panel');
  if (blockPanel) {
    blockPanel.style.display = show ? 'block' : 'none';
  }
}

/**
 * Update site name in UI and localStorage
 * @param {string} siteName - The site name to display
 */
function updateSiteNameInUI(siteName) {
  // Update UI
  const nameEl = document.querySelector("#site-name-nav span");
  if (nameEl) {
    nameEl.textContent = siteName;
  }
  
  // Update localStorage
  localStorage.setItem("siteName", siteName);
}

// Highlight recommended edges from AI response on the map
function highlightRecommendedEdges(aiResponse, analysis) {
  if (!aiResponse.recommendations) return;

  aiResponse.recommendations.forEach(rec => {
    if (rec.edgeId) {
      const edge = (analysis.edges || []).find(e => e.id === rec.edgeId);
      if (edge && edge.coordinates) {
        const geojson = {
          type: "Feature",
          geometry: {
            type: "LineString",
            coordinates: edge.coordinates
          },
          properties: {
            edgeId: edge.id,
            action: rec.action
          }
        };

        const sourceId = `ai-edge-${edge.id}`;
        const layerId = `ai-edge-layer-${edge.id}`;

        if (!map.getSource(sourceId)) {
          map.addSource(sourceId, { type: "geojson", data: geojson });
          map.addLayer({
            id: layerId,
            type: "line",
            source: sourceId,
            paint: {
              "line-color": rec.action === "create_access" ? "#FF0000" : "#00FF00",
              "line-width": 4
            }
          });
        } else {
          map.getSource(sourceId).setData(geojson);
        }
      }
    }
  });
}


// Ensure nav dropdown and AI handler are initialized only after DOM is fully loaded
window.addEventListener('load', () => {
  try {
    ensureSiteIdInUrl();
    console.log("🌐 Ensuring UI initialization after DOM load...");
    if (typeof initializeNavDropdown === 'function') {
      initializeNavDropdown();
    } else {
      console.error("❌ initializeNavDropdown not found at window load");
    }
  } catch (err) {
    console.error("❌ Error during post-load UI init:", err);
  }
});